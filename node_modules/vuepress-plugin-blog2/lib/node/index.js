"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@mr-hope/vuepress-shared"),t=require("@vuepress/core");function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n=a(require("chokidar"));const o=new e.Logger("vuepress-plugin-blog2"),r=(e,t)=>{const a={};Object.keys({"/":{},...t.options.locales}).forEach((e=>{a[e]=[]}));const{filter:n=(e=>Boolean(e.filePathRelative)&&!e.frontmatter.home)}=e;return t.pages.filter(n).forEach((e=>{a[e.pathLocale].push(e)})),a},p=e=>e.replace(/^\//,""),s=(e,a,n,r=!1)=>{const{category:s=[],slugify:i=(e=>e.replace(/[ _]/g,"-").toLowerCase())}=a;return Promise.all(s.map((async({key:a,getter:s,sorter:g=(()=>-1),path:l="",layout:c="Layout",frontmatter:u=(()=>({})),itemPath:y="",itemLayout:f="Layout",itemFrontmatter:h=(()=>({}))},m)=>{if("string"!=typeof a||!a)return o.error(`Invalid 'key' option ${a} in 'category[${m}]'`),null;if("function"!=typeof s)return o.error(`Invalid 'getter' option in 'category[${m}]', it should be a function!`),null;e.env.isDebug&&o.info(`Generating ${a} category.\n`);const d={},_=[],k="function"==typeof y?y:e=>y.replace(/:key/g,i(a)).replace(/:name/g,i(e));for(const y in n){if(l){const n=`${y}${p(l.replace(/:key/g,i(a)))}`,s=await t.createPage(e,{path:n,frontmatter:{...u(y),blog:{type:"category",key:a},layout:c}}),g=e.pages.findIndex((({path:e})=>e===n));-1===g?e.pages.push(s):e.pages[g].key!==s.key&&(e.pages.splice(g,1,s),r&&o.warn(`Overiding existed path ${n}`)),_.push(s.key),d[y]={path:s.path,map:{}}}else d[y]={path:"",map:{}};const{map:m}=d[y],$={};for(const i of n[y]){const n=s(i);for(const s of n){if(!m[s]){const n=k(s);if(n){const i=`${y}${p(n)}`,g=await t.createPage(e,{path:`${y}${p(n)}`,frontmatter:{...h(s,y),blog:{type:"category",name:s,key:a},layout:f}}),l=e.pages.findIndex((({path:e})=>e===i));-1===l?e.pages.push(g):e.pages[l].key!==g.key&&(e.pages.splice(l,1,g),r&&o.warn(`Overiding existed path ${i}`)),_.push(g.key),m[s]={path:g.path,keys:[]}}else m[s]={path:"",keys:[]};$[s]=[]}$[s].push(i)}}for(const e in $)m[e].keys=$[e].sort(g).map((({key:e})=>e));if(e.env.isDebug){let e=`Route ${y} in ${a} cateogry:\n`;for(const t in m){const{path:a,keys:n}=m[t];e+=`name: ${t}; ${a?`path: ${a}; `:""}items: ${n.length}\n`}o.info(e)}}return{key:a,map:d,pageKeys:_}}))).then((async t=>{const a={},n=[];return t.filter((e=>null!==e)).forEach((({key:e,map:t,pageKeys:o})=>{a[e]=t,n.push(...o)})),await e.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(a)}\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept()\n  if (__VUE_HMR_RUNTIME__.updateBlogCategory) {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)\n  }\n}\n\nif (import.meta.hot) {\n  import.meta.hot.accept(({ categoryMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)\n  })\n}\n`),e.env.isDebug&&o.info("All categories generated."),n}))},i=(e,a,n,r=!1)=>{const{type:s=[],slugify:i=(e=>e.replace(/[ _]/g,"-").toLowerCase())}=a;return Promise.all(s.map((async({key:a,sorter:s=(()=>-1),filter:g=(()=>!0),path:l="",layout:c="Layout",frontmatter:u=(()=>({}))},y)=>{if("string"!=typeof a||!a)return o.error(`Invalid 'key' option ${a} in 'category[${y}]'`),null;const f={},h=[];e.env.isDebug&&o.info(`Generating ${a} type.\n`);for(const y in n){const m=n[y].filter(g).sort(s).map((({key:e})=>e));if(l){const n=`${y}${p(i(l.replace(/:key/g,a)))}`,s=await t.createPage(e,{path:n,frontmatter:{...u(y),blog:{type:"type",key:a},layout:c}}),g=e.pages.findIndex((({path:e})=>e===n));-1===g?e.pages.push(s):e.pages[g].key!==s.key&&(e.pages.splice(g,1,s),r&&o.warn(`Overiding existed path ${n}`)),h.push(s.key),f[y]={path:s.path,keys:m},e.env.isDebug&&o.info(`Route ${y} in ${a} type: path: ${s.path}; items: ${m.length}\n`)}else f[y]={path:"",keys:m},e.env.isDebug&&o.info(`Route ${y} in ${a} type: items: ${m.length}\n`)}return{key:a,map:f,pageKeys:h}}))).then((async t=>{const a={},n=[];return t.filter((e=>null!==e)).forEach((({key:e,map:t,pageKeys:o})=>{a[e]=t,n.push(...o)})),await e.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(a)}\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept()\n  if (__VUE_HMR_RUNTIME__.updateBlogType) {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)\n  }\n}\n\nif (import.meta.hot) {\n  import.meta.hot.accept(({ typeMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)\n  })\n}\n`),e.env.isDebug&&o.info("All types generated."),n}))},g=a=>{const{metaScope:p="_blog"}=a;let g=[];return{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:p}),extendsPage:e=>{const{getInfo:t=(()=>({}))}=a;e.routeMeta={...""===p?t(e):{[p]:t(e)},...e.routeMeta}},onInitialized:t=>{e.addViteSsrNoExternal(t,["@mr-hope/vuepress-shared","vuepress-plugin-blog2"]),e.addViteOptimizeDepsExclude(t,"vuepress-plugin-blog2");const n=r(a,t);return Promise.all([s(t,a,n,!0).then((e=>{g.push(...e)})),i(t,a,n,!0).then((e=>{g.push(...e)}))]).then((()=>{t.env.isDebug&&o.info("temp file generated")}))},onWatched:(e,p)=>{if(a.hotReload){const l=n.default.watch("pages/**/*.js",{cwd:e.dir.temp(),ignoreInitial:!0}),c=()=>{const n=[],p=r(a,e);return Promise.all([s(e,a,p).then((e=>{n.push(...e)})),i(e,a,p).then((e=>{n.push(...e)}))]).then((async()=>{const a=g.filter((e=>!n.includes(e)));a.length?(e.env.isDebug&&o.info(`Removing following pages: ${a.toString()}`),a.forEach((t=>{e.pages.splice(e.pages.findIndex((({key:e})=>e===t)),1)})),await t.preparePagesComponents(e),await t.preparePagesData(e),await t.preparePagesRoutes(e)):n.length!==g.length&&(e.env.isDebug&&o.info("New pages detected"),await t.preparePagesComponents(e),await t.preparePagesData(e),await t.preparePagesRoutes(e)),g=n,e.env.isDebug&&o.info("temp file updated")}))};l.on("add",(()=>{c()})),l.on("change",(()=>{c()})),l.on("unlink",(()=>{c()})),p.push(l)}}}};exports.blog=e=>["blog2",e],exports.blogPlugin=g,exports.default=g;
//# sourceMappingURL=index.js.map
